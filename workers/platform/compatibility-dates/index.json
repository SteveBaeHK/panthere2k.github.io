[{"description":"Adds the work-in-progress `new ReadableStream()` and `new WritableStream()` constructors backed by JavaScript underlying sources and sinks.","disable_flag":"streams_disable_constructors","enable_date":"2022-11-30","enable_flag":"streams_enable_constructors","experimental":false,"name":"Streams Constructors"},{"description":"Previously, the `new TransformStream()` constructor was not compliant with the Streams API standard. Use the `transformstream_enable_standard_constructor` to opt-in to the backwards-incompatible change to make the constructor compliant. Must be used in combination with the `streams_enable_constructors` flag.","disable_flag":"transformstream_disable_standard_constructor","enable_date":"2022-11-30","enable_flag":"transformstream_enable_standard_constructor","experimental":false,"name":"Compliant TransformStream constructor"},{"description":"CommonJS modules were previously exporting a module namespace (an object like `{ default: module.exports }`) rather than exporting only the `module.exports`. When this flag is enabled, the export is fixed.","disable_flag":"export_commonjs_namespace","enable_date":"2022-10-31","enable_flag":"export_commonjs_default","experimental":false,"name":"CommonJS modules do not export a module namespace"},{"description":"The `capture_async_api_throws` compatibility flag will ensure that, in conformity with the standards API, async functions will only ever reject if they throw an error. The inverse `do_not_capture_async_api_throws` flag means that async functions which contain an error may throw that error synchronously rather than rejecting.","disable_flag":"do_not_capture_async_api_throws","enable_date":"2022-10-31","enable_flag":"capture_async_api_throws","experimental":false,"name":"Do not throw from async functions"},{"description":"The original Workers `URL` API implementation is not fully compliant with the [WHATWG URL Standard](https://url.spec.whatwg.org/). Cloudflare has added a new implementation that is fully compliant. However, since the new implementation is not completely backwards compatible, it is disabled by default. Use the `url_standard` flag to enable the new implementation.","disable_flag":"url_original","enable_date":"2022-10-31","enable_flag":"url_standard","experimental":false,"name":"New URL parser implementation"},{"description":"With the `r2_list_honor_include` flag set, the `include` argument to R2 `list` options is honored. With an older compatability date and without this flag, the `include` argument behaves implicitly as `include: [\"httpMetadata\", \"customMetadata\"]`.","disable_flag":null,"enable_date":"2022-08-04","enable_flag":"r2_list_honor_include","experimental":false,"name":"`R2` bucket `list` respects the `include` option"},{"description":"There was a bug in the runtime that meant that when being passed into built-in APIs, invalid values were sometimes mistakenly coalesced with `null`. Instead, a `TypeError` should have been thrown. The `dont_substitute_null_on_type_error` fixes this behavior so that an error is correctly thrown in these circumstances.","disable_flag":"substitute_null_on_type_error","enable_date":"2022-06-01","enable_flag":"dont_substitute_null_on_type_error","experimental":false,"name":"Do not substitute `null` on `TypeError`"},{"description":"With the `minimal_subrequests` flag set, `fetch()` subrequests sent to endpoints on the Worker's own zone (also called same-zone subrequests) have a reduced set of features applied to them. In general, these features should not have been initially applied to same-zone subrequests, and very few user-facing behavior changes are anticipated. Specifically, Workers might observe the following behavior changes with the new flag:\n\n- Response bodies will not be opportunistically gzipped before being transmitted to the Workers runtime. If a Worker reads the response body, it will read it in plaintext, as has always been the case, so disabling this prevents unnecessary decompression. Meanwhile, if the Worker passes the response through to the client, Cloudflare's HTTP proxy will opportunistically gzip the response body on that side of the Workers runtime instead. The behavior change observable by a Worker script should be that some `Content-Encoding: gzip` headers will no longer appear.\n- Automatic Platform Optimization may previously have been applied on both the Worker's initiating request and its subrequests in some circumstances. It will now only apply to the initiating request.\n- Link prefetching will now only apply to the Worker's response, not responses to the Worker's subrequests.","disable_flag":"no_minimal_subrequests","enable_date":"2022-04-05","enable_flag":"minimal_subrequests","experimental":false,"name":"Minimal subrequests"},{"description":"With the `global_navigator` flag set, a new global `navigator` property is available from within Workers. Currently, it exposes only a single `navigator.userAgent` property whose value is set to `'Cloudflare-Workers'`. This property can be used to reliably determine whether code is running within the Workers environment.","disable_flag":"no_global_navigator","enable_date":"2022-03-21","enable_flag":"global_navigator","experimental":false,"name":"Global `navigator`"},{"description":"The `no_cots_on_external_fetch` flag disables the use of the [Custom Origin Trust Store](https://developers.cloudflare.com/ssl/origin-configuration/custom-origin-trust-store/) when making external (grey-clouded) subrequests from a Cloudflare Worker.","disable_flag":"cots_on_external_fetch","enable_date":"2022-03-08","enable_flag":"no_cots_on_external_fetch","experimental":false,"name":"Do not use the Custom Origin Trust Store for external subrequests"},{"description":"Originally, properties on Workers API objects were defined as instance properties as opposed to prototype properties. This broke subclassing at the JavaScript layer, preventing a subclass from correctly overriding the superclass getters/setters. This flag controls the breaking change made to set those getters/setters on the prototype template instead.\n\nThis changes applies to:\n\n- `AbortSignal`\n- `AbortController`\n- `Blob`\n- `Body`\n- `DigestStream`\n- `Event`\n- `File`\n- `Request`\n- `ReadableStream`\n- `ReadableStreamDefaultReader`\n- `ReadableStreamBYOBReader`\n- `Response`\n- `TextDecoder`\n- `TextEncoder`\n- `TransformStream`\n- `URL`\n- `WebSocket`\n- `WritableStream`\n- `WritableStreamDefaultWriter`","disable_flag":"workers_api_getters_setters_on_instance","enable_date":"2022-01-31","enable_flag":"workers_api_getters_setters_on_prototype","experimental":false,"name":"Setters/getters on API object prototypes"},{"description":"Originally, when making a request to a Durable Object by calling `stub.fetch(url)`, a relative URL was accepted as an input. The URL would be interpreted relative to the dummy URL `http://fake-host`, and the resulting absolute URL was delivered to the destination object's `fetch()` handler. This was a mistake â€” full URLs were meant to be required. This flag makes full URLs required.","disable_flag":"durable_object_fetch_allows_relative_url","enable_date":"2021-11-10","enable_flag":"durable_object_fetch_requires_full_url","experimental":false,"name":"Durable Object `stub.fetch()` requires a full URL"},{"description":"Originally, if the `fetch()` function was passed a URL specifying any protocol other than `http:` or `https:`, it would silently treat it as if it were `http:`. For example, `fetch()` would appear to accept `ftp:` URLs, but it was actually making HTTP requests instead.\n\nNote that Cloudflare Workers supports a non-standard extension to `fetch()` to make it support WebSockets. However, when making an HTTP request that is intended to initiate a WebSocket handshake, you should still use `http:` or `https:` as the protocol, not `ws:` nor `wss:`.\n\nThe `ws:` and `wss:` URL schemes are intended to be used together with the `new WebSocket()` constructor, which exclusively supports WebSocket. The extension to `fetch()` is designed to support HTTP and WebSocket in the same request (the response may or may not choose to initiate a WebSocket), and so all requests are considered to be HTTP.","disable_flag":"fetch_treats_unknown_protocols_as_http","enable_date":"2021-11-10","enable_flag":"fetch_refuses_unknown_protocols","experimental":false,"name":"`fetch()` improperly interprets unknown protocols as HTTP"},{"description":"Originally, the Workers runtime did not detach the `ArrayBuffer`s from user-provided TypedArrays when using the [BYOB reader's `read()` method](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestreambyobreader/#methods), as required by the Streams spec, meaning it was possible to inadvertently reuse the same buffer for multiple `read()` calls. This change makes Workers conform to the spec.\n\nUser code should never try to reuse an `ArrayBuffer` that has been passed into a [BYOB reader's `read()` method](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestreambyobreader/#methods). Instead, user code can reuse the `ArrayBuffer` backing the result of the `read()` promise, as in the example below.\n\n```js\n// Consume and discard `readable` using a single 4KiB buffer.\nlet reader = readable.getReader({ mode: \"byob\" });\nlet arrayBufferView = new Uint8Array(4096);\nwhile (true) {\n  let result = await reader.read(arrayBufferView);\n  if (result.done) break;\n  // Optionally something with `result` here.\n  // Re-use the same memory for the next `read()` by creating\n  // a new Uint8Array backed by the result's ArrayBuffer.\n  arrayBufferView = new Uint8Array(result.value.buffer);\n}\n```\n\nThe more recently added extension method `readAtLeast()` will always detach the `ArrayBuffer` and is unaffected by this feature flag setting.","disable_flag":"streams_byob_reader_does_not_detach_buffer","enable_date":"2021-11-10","enable_flag":"streams_byob_reader_detaches_buffer","experimental":false,"name":"Streams BYOB reader detaches buffer"},{"description":"[The `FormData` API](https://developer.mozilla.org/en-US/docs/Web/API/FormData) is used to parse data (especially HTTP request bodies) in `multipart/form-data` format.\n\nOriginally, the Workers runtime's implementation of the `FormData` API incorrectly converted uploaded files to strings. Therefore, `formData.get(\"filename\")` would return a string containing the file contents instead of a `File` object. This change fixes the problem, causing files to be represented using `File` as specified in the standard.","disable_flag":"formdata_parser_converts_files_to_strings","enable_date":"2021-11-03","enable_flag":"formdata_parser_supports_files","experimental":false,"name":"`FormData` parsing supports `File`"},{"description":"The HTML5 standard defines a fixed set of elements as void elements, meaning they do not use an end tag: `\u003carea\u003e`, `\u003cbase\u003e`, `\u003cbr\u003e`, `\u003ccol\u003e`, `\u003ccommand\u003e`, `\u003cembed\u003e`, `\u003chr\u003e`, `\u003cimg\u003e`, `\u003cinput\u003e`, `\u003ckeygen\u003e`, `\u003clink\u003e`, `\u003cmeta\u003e`, `\u003cparam\u003e`, `\u003csource\u003e`, `\u003ctrack\u003e`, and `\u003cwbr\u003e`.\n\nHTML5 does not recognize XML self-closing tag syntax. For example, `\u003cscript src=\"foo.js\" /\u003e` does not specify a script element with no body. A `\u003c/script\u003e` ending tag is still required. The `/\u003e` syntax simply is not recognized by HTML5 at all and it is treated the same as `\u003e`. However, many developers still like to use this syntax, as a holdover from XHTML, a standard which failed to gain traction in the early 2000's.\n\n`\u003cesi:include\u003e` and `\u003cesi:comment\u003e` are two tags that are not part of the HTML5 standard, but are instead used as part of [Edge Side Includes](https://en.wikipedia.org/wiki/Edge_Side_Includes), a technology for server-side HTML modification. These tags are not expected to contain any body and are commonly written with XML self-closing syntax.\n\n`HTMLRewriter` was designed to parse standard HTML5, not ESI. However, it would be useful to be able to implement some parts of ESI using `HTMLRewriter`. To that end, this compatibility flag causes `HTMLRewriter` to treat `\u003cesi:include\u003e` and `\u003cesi:comment\u003e` as void tags, so that they can be parsed and handled properly.","disable_flag":null,"enable_date":null,"enable_flag":"html_rewriter_treats_esi_include_as_void_tag","experimental":true,"name":"`HTMLRewriter` handling of `\u003cesi:include\u003e`"}]